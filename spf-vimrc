" Plugins, if vim-plug works
if (has('job') || g:python_version || has('nvim') || has('lua'))

    function! HasDirectory(dir)
        return isdirectory(expand($PLUG_PATH."/".a:dir))
    endfunction

    " voom
    if HasDirectory('VOom')
        let g:voom_python_versions = [3,2]
        if has('gui_running')
            au FileType markdown nmap <silent> <C-q> :Voom markdown<Cr>
            au FileType markdown vmap <silent> <C-q> <ESC>:Voom markdown<Cr>
            au FileType markdown imap <silent> <C-q> <ESC>:Voom markdown<Cr>
        endif
        nmap <leader>vt :VoomToggle<CR>
        nmap <leader>vv :VoomQuit<CR>:Voom<CR><C-w>w
        let g:voom_tab_key = "<C-Tab>"
        let g:voom_ft_modes = {
            \ 'markdown': 'markdown',
            \ 'pandoc': 'pandoc',
            \ 'c': 'fmr2',
            \ 'cpp': 'fmr2',
            \ 'python':'python',
            \ 'tex': 'latex'}
    endif

    " autopairs
    if HasDirectory("auto-pairs")
        let g:AutoPairs = {'(':')', '[':']', '{':'}','`':'`'}
        let g:AutoPairsShortcutToggle     = "<C-b>t"
        let g:AutoPairsShortcutFastWrap   = "<C-b>f"
        let g:AutoPairsShortcutJump       = "<C-b>j"
        let g:AutoPairsShortcutBackInsert = "<C-b>i"
        inoremap <buffer> <silent> <BS> <C-R>=AutoPairsDelete()<CR>
    endif

    " bufferline
    if HasDirectory("vim-bufferline")
        let g:bufferline_show_bufnr = 0
        let g:bufferline_rotate = 1
        let g:bufferline_fixed_index =  0
    endif

    " conflict-marker
    if HasDirectory("conflict-marker.vim")
        let g:conflict_marker_enable_mappings = 1
    endif

    " search tools
    if HasDirectory('FlyGrep.vim')
        nmap <C-f><C-f> :FlyGrep<Cr>
    endif
    if HasDirectory('ctrlsf.vim')
        let g:ctrlsf_position='right'
        nmap <C-F>s <Plug>CtrlSFPrompt
        nmap <C-F>c <Plug>CtrlSFCwordPath
        nmap <C-F>p <Plug>CtrlSFPwordPath
        nmap <C-F>o :CtrlSFOpen<CR>
        nmap <C-F>t :CtrlSFToggle<CR>
        " vmap
        vmap <C-F>s <Plug>CtrlSFVwordExec
        vmap <C-F>f <Plug>CtrlSFVwordPath
    elseif HasDirectory('vim-finder')
        nnoremap <C-f>s :finder<Space>
    else
        nnoremap <C-f>s :vimgrep<Space>
    endif

    " Shell
    if has('terminal')
        tnoremap <C-[> <C-\><C-n>
        tnoremap <ESC> <C-\><C-n>
        tnoremap <C-w>h <C-\><C-N><C-w>h
        tnoremap <C-w>j <C-\><C-N><C-w>j
        tnoremap <C-w>k <C-\><C-N><C-w>k
        tnoremap <C-w>l <C-\><C-N><C-w>l
        tnoremap <C-w><right> <C-\><C-N><C-w><right>
        tnoremap <C-w><left>  <C-\><C-N><C-w><left>
        tnoremap <C-w><down>  <C-\><C-N><C-w><down>
        tnoremap <C-w><up>    <C-\><C-N><C-w><up>

            nmap <C-h>v :vertical terminal<cr>bash<cr>
            nmap <C-h>h :terminal<cr>bash<cr>
            nmap <C-h>t :tab terminal<Cr>bash<Cr>
            nmap <C-h>V :vertical terminal
            nmap <C-h>H :terminal
            nmap <C-h>T :tab terminal
    endif

    " PyMode
    if HasDirectory("python-mode")
        " python version
        if g:python_version     == 3
            let g:pymode_python  = 'python3'
        else
            let g:pymode_python  = 'python'
        endif
        let g:pymode_syntax = 0
        let g:pymode_syntax_all = 0
        " disable pymode_rope and pymode_folding for slow problem
        let g:pymode_rope             = 0
        let g:pymode_folding          = 0
        let g:pymode_trim_whiteSpaces = 0
        let g:pymode_options          = 0
        " doc for python
        let g:pymode_doc              = 1
        " motion
        let g:pymode_motion           = 1
        " run python
        let g:pymode_run_bind         = '<leader>R'
        " breakpoint
        let g:pymode_breakpoint       = 1
        let g:pymode_breakpoint_bind  = '<BS>'
        let g:pymode_breakpoint_cmd   = 'import pdb;pdb.set_trace()'
        " pymode check disable
        if count(g:plug_groups, 'syntax')
            let g:pymode_lint = 0
            let g:pymode_rope_goto_definition_bind = '<Nop>'
        else
            nmap <C-l><C-l> :PymodeLint<CR>
            let g:pymode_rope_goto_definition_bind = 'gd'
            let g:pymode_lint            = 1
            let g:pymode_lint_signs      = 1
            " no check when write
            let g:pymode_lint_on_write   = 0
            " check when save
            let g:pymode_lint_unmodified = 0
            " not check of fly
            let g:pymode_lint_on_fly     = 0
            " show message of error line
            let g:pymode_lint_message    = 1
            " checkers
            let g:pymode_lint_checkers   = ['pyflakes', 'pep8']
            let g:pymode_lint_ignore     = "E128,E2,E3,E501"
            " not Auto open cwindow (quickfix) if any errors have been found
            let g:pymode_lint_cwindow    = 0
        endif
    endif

    " browser seris
    if g:browser_tool == 'denite' && HasDirectory("denite.nvim")
        nnoremap <C-p> :Denite file/rec buffer<Cr>
        nnoremap <leader>lf :Denite
        nnoremap <leader>lb :DeniteBufferDir
        nnoremap <leader>lw :DeniteCursorWord
        nnoremap <Leader>/ :call denite#start([{'name': 'grep', 'args': ['', '', '!']}])<cr>
        call denite#custom#option('_', {
                \ 'prompt': 'λ:',
                \ 'empty': 0,
                \ 'winheight': 16,
                \ 'source_names': 'short',
                \ 'vertical_preview': 1,
                \ 'auto-accel': 1,
                \ 'auto-resume': 1,
            \ })
        call denite#custom#option('list', {})
        call denite#custom#option('mpc', {
                \ 'quit': 0,
                \ 'mode': 'normal',
                \ 'winheight': 20,
            \ })
        " MATCHERS
        " Default is 'matcher_fuzzy'
        call denite#custom#source('tag', 'matchers', ['matcher_substring'])
        if has('nvim') && &runtimepath =~# '\/cpsm'
            call denite#custom#source(
                \ 'buffer,file_mru,file_old,file_rec,grep,mpc,line',
                \ 'matchers', ['matcher_cpsm', 'matcher_fuzzy'])
        endif
        " SORTERS
        " Default is 'sorter_rank'
        call denite#custom#source('z', 'sorters', ['sorter_z'])
        " CONVERTERS
        " Default is none
        call denite#custom#source(
            \ 'buffer,file_mru,file_old',
            \ 'converters', ['converter_relative_word'])
        " FIND and GREP COMMANDS
        if executable('ag')
            " The Silver Searcher
            call denite#custom#var('file_rec', 'command',
                \ ['ag', '-U', '--hidden', '--follow', '--nocolor', '--nogroup', '-g', ''])
            " Setup ignore patterns in your .agignore file!
            " https://github.com/ggreer/the_silver_searcher/wiki/Advanced-Usage
            call denite#custom#var('grep', 'command', ['ag'])
            call denite#custom#var('grep', 'recursive_opts', [])
            call denite#custom#var('grep', 'pattern_opt', [])
            call denite#custom#var('grep', 'separator', ['--'])
            call denite#custom#var('grep', 'final_opts', [])
            call denite#custom#var('grep', 'default_opts',
                \ [ '--skip-vcs-ignores', '--vimgrep', '--smart-case', '--hidden' ])
        elseif executable('ack')
            " Ack command
            call denite#custom#var('grep', 'command', ['ack'])
            call denite#custom#var('grep', 'recursive_opts', [])
            call denite#custom#var('grep', 'pattern_opt', ['--match'])
            call denite#custom#var('grep', 'separator', ['--'])
            call denite#custom#var('grep', 'final_opts', [])
            call denite#custom#var('grep', 'default_opts',
                \ ['--ackrc', $HOME.'/.config/ackrc', '-H',
                \ '--nopager', '--nocolor', '--nogroup', '--column'])
        endif
        " KEY MAPPINGS
        let insert_mode_mappings = [
                \  ['<C-c>', '<denite:enter_mode:normal>', 'noremap'],
                \  ['<Esc>', '<denite:enter_mode:normal>', 'noremap'],
                \  ['<C-N>', '<denite:assign_next_matched_text>', 'noremap'],
                \  ['<C-P>', '<denite:assign_previous_matched_text>', 'noremap'],
                \  ['<Up>', '<denite:assign_previous_text>', 'noremap'],
                \  ['<Down>', '<denite:assign_next_text>', 'noremap'],
                \  ['<C-Y>', '<denite:redraw>', 'noremap'],
            \ ]
        let normal_mode_mappings = [
                \   ["'", '<denite:toggle_select_down>', 'noremap'],
                \   ['<C-n>', '<denite:jump_to_next_source>', 'noremap'],
                \   ['<C-p>', '<denite:jump_to_previous_source>', 'noremap'],
                \   ['gg', '<denite:move_to_first_line>', 'noremap'],
                \   ['st', '<denite:do_action:tabopen>', 'noremap'],
                \   ['vs', '<denite:do_action:vsplit>', 'noremap'],
                \   ['sv', '<denite:do_action:split>', 'noremap'],
                \   ['qt', '<denite:quit>', 'noremap'],
                \   ['r', '<denite:redraw>', 'noremap'],
            \ ]
        for m in insert_mode_mappings
            call denite#custom#map('insert', m[0], m[1], m[2])
        endfor
        for m in normal_mode_mappings
            call denite#custom#map('normal', m[0], m[1], m[2])
        endfor
    endif

    " UndoTree
    if HasDirectory("undotree")
        nnoremap <silent><leader>u :UndotreeToggle<CR>
        " If undotree is opened, it is likely one wants to interact with it.
        let g:undotree_SetFocusWhenToggle = 0
        if has("persistent_undo")
            set undodir=~/.vim/undodir/
            set undofile
        endif
    endif

    " complete_engine && complete_snippet
    set completeopt-=menu
    set completeopt-=preview
    set completeopt+=menuone
    " ominifuc
    autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
    autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
    autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
    autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
    autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
    if HasDirectory("YouCompleteMe") && g:complete_engine == "YCM"
        set shortmess+=c
        set completeopt+=noinsert,noselect
        if g:python_version == 2
            let g:ycm_python_binary_path = 'python'
        else
            let g:ycm_python_binary_path = 'python3'
        endif
        " add_preview
        let g:ycm_add_preview_to_completeopt = 1
        "  补全后close窗口
        let g:ycm_autoclose_preview_window_after_completion = 1
        "  插入后close窗口
        let g:ycm_autoclose_preview_window_after_insertion = 1
        " enable completion from tags
        let g:ycm_collect_identifiers_from_tags_files = 1
        let g:ycm_key_list_select_completion = ['<C-n>', '<Down>']
        let g:ycm_key_list_previous_completion = ['<C-p', '<Up>']
        let g:ycm_filetype_blacklist = {
            \ 'tagbar' : 1,
            \ 'nerdtree' : 1,
        \}
        let g:ycm_semantic_triggers =  {
            \ 'c' : ['->', '.'],
            \ 'objc' : ['->', '.', 're!\[[_a-zA-Z]+\w*\s', 're!^\s*[^\W\d]\w*\s', 're!\[.*\]\s'],
            \ 'ocaml' : ['.', '#'],
            \ 'cpp,cuda,objcpp' : ['->', '.', '::'],
            \ 'perl' : ['->'],
            \ 'php' : ['->', '::'],
            \ 'cs,java,javascript,typescript,d,python,perl6,scala,vb,elixir,go' : ['.'],
            \ 'ruby' : ['.', '::'],
            \ 'lua' : ['.', ':'],
            \ 'erlang' : [':'],
        \ }
        let g:ycm_confirm_extra_conf = 1 "加载.ycm_extra_conf.py提示
        let g:ycm_global_ycm_extra_conf = $PLUG_PATH."/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py"
        let g:ycm_key_invoke_completion = ''
        let g:ycm_collect_identifiers_from_tags_files = 1    " 开启 YC基于标签引擎
        let g:ycm_min_num_of_chars_for_completion = 2   " 从第2个键入字符就开始罗列匹配项
        let g:ycm_seed_identifiers_with_syntax = 1   " 语法关键字补全
        let g:ycm_complete_in_comments = 0
        let g:ycm_complete_in_strings = 1
        let g:ycm_collect_identifiers_from_comments_and_strings = 0
        " 跳转到定义处
        nnoremap go :YcmCompleter GoToDefinitionElseDeclaration<CR>
    elseif HasDirectory("deoplete.nvim") && g:complete_engine == "deoplete"
        set shortmess+=c
        set completeopt+=noinsert,noselect
        let g:deoplete#enable_at_startup = 1
        " <BS>: close popup and delete backword char.
        inoremap <expr><BS> deoplete#smart_close_popup()."\<C-h>"
        if !has('nvim')
            let g:deoplete#enable_yarp = 1
        endif
        let g:deoplete#enable_camel_case = 1
        " Enable heavy omni completion.
        if !exists('g:deoplete#keyword_patterns')
            let g:deoplete#keyword_patterns = {}
        endif
        call deoplete#custom#option('omni_patterns', {
            \ 'java' : '[^. *\t]\.\w*',
            \ 'php'  : '[^. \t]->\h\w*\|\h\w*::',
            \ 'perl' : '\h\w*->\h\w*\|\h\w*::',
            \ 'c'    : '[^.[:digit:] *\t]\%(\.\|->\)',
            \ 'cpp'  : '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::',
            \ 'ruby' : '[^. *\t]\.\h\w*\|\h\w*::',
            \ 'go'   : '\h\w*\.\?',
        \})
        if HasDirectory('ultisnips')
            call deoplete#custom#source('ultisnips', 'matchers', ['matcher_fuzzy'])
        endif
    elseif HasDirectory("ncm2") && g:complete_engine == "ncm2"
        set shortmess+=c
        set completeopt+=noinsert,noselect
        autocmd BufEnter * call ncm2#enable_for_buffer()
        au User Ncm2Plugin call ncm2#register_source({
            \ 'name' : 'css',
            \ 'enable' : 1,
            \ 'priority': 9,
            \ 'subscope_enable': 1,
            \ 'scope': ['css','scss'],
            \ 'mark': 'css',
            \ 'word_pattern': '[\w\-]+',
            \ 'complete_pattern': ':\s*',
            \ 'on_complete': ['ncm2#on_complete#omni', 'csscomplete#CompleteCSS']
            \ })
        let g:LanguageClient_serverCommands = {
            \ 'go': ['go-langserver'],
            \ 'rust': ['rls'],
            \ 'javascript': ['tcp://127.0.0.1:2089'],
            \ 'python': ['pyls'],
            \ }
    elseif HasDirectory("coc.nvim") && g:complete_engine == "coc"
        set shortmess+=c
        let g:coc_sinnpet_next = "<C-f>"
        let g:coc_sinnpet_prev = "<C-b>"
    elseif HasDirectory("asyncomplete.vim") && g:complete_engine == "asyncomplete"
        set shortmess+=c
        set completeopt+=noinsert,noselect
        let g:asyncomplete_auto_popup = 1
        if v:version >= 800
            if has('nvim') || has('lua')
                let g:asyncomplete_smart_completion = 1
            endif
        endif
        au User asyncomplete_setup call asyncomplete#register_source(asyncomplete#sources#buffer#get_source_options({
            \ 'name': 'buffer',
            \ 'whitelist': ['*'],
            \ 'blacklist': ['go'],
            \ 'completor': function('asyncomplete#sources#buffer#completor'),
            \ }))
        au User asyncomplete_setup call asyncomplete#register_source(asyncomplete#sources#file#get_source_options({
            \ 'name': 'file',
            \ 'whitelist': ['*'],
            \ 'priority': 10,
            \ 'completor': function('asyncomplete#sources#file#completor')
            \ }))
        au User asyncomplete_setup call asyncomplete#register_source(asyncomplete#sources#omni#get_source_options({
            \ 'name': 'omni',
            \ 'whitelist': ['*'],
            \ 'blacklist': ['c', 'cpp', 'html'],
            \ 'completor': function('asyncomplete#sources#omni#completor')
            \  }))
        au User asyncomplete_setup call asyncomplete#register_source(asyncomplete#sources#necosyntax#get_source_options({
            \ 'name': 'necosyntax',
            \ 'whitelist': ['*'],
            \ 'completor': function('asyncomplete#sources#necosyntax#completor'),
            \ }))
        if HasDirectory("asyncomplete-ultisnips.vim")
            au User asyncomplete_setup call asyncomplete#register_source(asyncomplete#sources#ultisnips#get_source_options({
                \ 'name': 'ultisnips',
                \ 'whitelist': ['*'],
                \ 'completor': function('asyncomplete#sources#ultisnips#completor')
                \ }))
        elseif HasDirectory("asyncomplete-neosnippet.vim")
            au User asyncomplete_setup call asyncomplete#register_source(asyncomplete#sources#neosnippet#get_source_options({
                \ 'name': 'neosnippet',
                \ 'whitelist': ['*'],
                \ 'completor': function('asyncomplete#sources#neosnippet#completor')
                \ }))
        endif
    elseif HasDirectory("neocomplete.vim") && g:complete_engine == "neocomplete"
        let g:neocomplete#enable_at_startup = 1
        let g:neocomplete#enable_smart_case = 1
        let g:neocomplete#enable_auto_select = 0
        let g:neocomplete#enable_camel_case = 1
        let g:neocomplete#enable_auto_delimiter = 0
        let g:neocomplete#force_overwrite_completefunc = 1
        " <BS>: close popup and delete backword char.
        inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
        " Enable heavy omni completion.
        if !exists('g:neocomplete#force_omni_input_patterns')
            let g:neocomplete#force_omni_input_patterns = {}
        endif
        let g:neocomplete#force_omni_input_patterns.java = '[^. \t]\.\w*'
        let g:neocomplete#force_omni_input_patterns.php  = '[^. \t]->\h\w*\|\h\w*::'
        let g:neocomplete#force_omni_input_patterns.perl = '\h\w*->\h\w*\|\h\w*::'
        let g:neocomplete#force_omni_input_patterns.c    = '[^.[:digit:] *\t]\%(\.\|->\)'
        let g:neocomplete#force_omni_input_patterns.cpp  = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'
        let g:neocomplete#force_omni_input_patterns.ruby = '[^. *\t]\.\h\w*\|\h\w*::'
        let g:neocomplete#force_omni_input_patterns.go   = '\h\w*\.\?'
    elseif HasDirectory("neocomplcache.vim") && g:complete_engine == "neocomplcache"
        let g:neocomplcache_enable_insert_char_pre       = 1
        let g:neocomplcache_enable_at_startup            = 1
        let g:neocomplcache_enable_auto_select           = 0
        let g:neocomplcache_enable_camel_case_completion = 1
        let g:neocomplcache_enable_smart_case            = 1
        let g:neocomplcache_enable_auto_delimiter        = 0
        let g:neocomplcache_force_overwrite_completefunc = 1
        " <BS>: close popup and delete backword char.
        inoremap <expr><BS> neocomplcache#smart_close_popup()."\<C-h>"
        " Enable heavy omni completion.
        if !exists('g:neocomplcache_omni_patterns')
            let g:neocomplcache_omni_patterns = {}
        endif
        let g:neocomplcache_omni_patterns.java = '[^. \t]\.\w*'
        let g:neocomplcache_omni_patterns.php  = '[^. \t]->\h\w*\|\h\w*::'
        let g:neocomplcache_omni_patterns.perl = '\h\w*->\h\w*\|\h\w*::'
        let g:neocomplcache_omni_patterns.c    = '[^.[:digit:] *\t]\%(\.\|->\)'
        let g:neocomplcache_omni_patterns.cpp  = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'
        let g:neocomplcache_omni_patterns.ruby = '[^. *\t]\.\h\w*\|\h\w*::'
        let g:neocomplcache_omni_patterns.go   = '\h\w*\.\?'
    endif

    " smart completion use neosnippet to expand
    if g:complete_engine !="None"
        " headache confict
        imap <expr><C-j>  pumvisible()? "()\<Left>":"\<CR>"
        if g:complete_engine == "YCM" || g:complete_engine == "asyncomplete"
            imap <expr><Cr>  pumvisible()? "\<C-[>a":"\<CR>"
        else
            imap <expr><Cr>  pumvisible()? "\<C-y>":"\<CR>"
        endif
        inoremap <expr> <Up>       pumvisible() ? "\<C-p>"                  : "\<Up>"
        inoremap <expr> <Down>     pumvisible() ? "\<C-n>"                  : "\<Down>"
        inoremap <expr> <PageUp>   pumvisible() ? "\<PageUp>\<C-p>\<C-n>"   : "\<PageUp>"
        inoremap <expr> <PageDown> pumvisible() ? "\<PageDown>\<C-n>\<C-p>" : "\<PageDown>"
        " ultisnip
        if HasDirectory('ultisnips')
            " remap Ultisnips for compatibility
            let g:UltiSnipsNoPythonWarning = 0
            let g:UltiSnipsExpandTrigger = "<Nop>"
            let g:UltiSnipsListSnippets = "<C-l>"
            let g:UltiSnipsJumpForwardTrigger = '<C-f>'
            let g:UltiSnipsJumpBackwardTrigger = '<C-b>'
            " Ulti python version
            let g:UltiSnipsUsePythonVersion = g:python_version
            " tab for ExpandTrigger
            function! g:UltiSnips_Tab()
                if pumvisible()
                    call UltiSnips#ExpandSnippet()
                    if g:ulti_expand_res
                        return "\<Right>"
                    else
                        if !exists('v:completed_item') || empty(v:completed_item)
                            return "\<C-n>"
                        else
                            return "\<C-y>"
                        endif
                    endif
                else
                    return "\<Tab>"
                endif
            endfunction
            au BufEnter * exec "inoremap <silent> <Tab> <C-R>=g:UltiSnips_Tab()<cr>"
            au BufEnter * exec "inoremap <silent> <C-k> <C-R>=g:UltiSnips_Tab()<cr>"
            " Ulti的代码片段的文件夹
            let g:UltiSnipsSnippetsDir = $PLUG_PATH."/leoatchina-snippets/UltiSnips"
            let g:UltiSnipsSnippetDirectories=["UltiSnips"]
        elseif HasDirectory('neosnippet')
            let g:neosnippet#enable_completed_snippet = 1
            " c-f to jump
            smap <C-f> <Plug>(neosnippet_jump)
            function! g:NeoSnippet_Tab()
                if pumvisible()
                    if neosnippet#expandable()
                        return neosnippet#mappings#expand_impl()
                    else
                        if !exists('v:completed_item') || empty(v:completed_item)
                            return "\<C-n>"
                        else
                            return "\<C-y>"
                        endif
                    endif
                else
                    return "\<Tab>"
                endif
            endfunction
            au BufEnter * exec "inoremap <silent> <Tab> <C-R>=g:NeoSnippet_Tab()<cr>"
            au BufEnter * exec "inoremap <silent> <C-k> <C-R>=g:NeoSnippet_Tab()<cr>"
            " Use honza's snippets.
            let g:neosnippet#snippets_directory=$PLUG_PATH.'/vim-snippets/snippets'
            " Enable neosnippets when using go
            if count(g:plug_groups, 'go')
                let g:go_snippet_engine = "neosnippet"
            endif
        endif
    endif

    if HasDirectory("ale")
        let g:ale_completion_enabled   = 0
        let g:ale_lint_on_enter        = 1
        let g:ale_lint_on_text_changed = 'always'
        " signs
        let g:ale_sign_column_always   = 1
        let g:ale_set_signs            = 1
        let g:ale_set_highlights       = 0
        let g:ale_sign_error           = 'E'
        let g:ale_sign_warning         = 'w'
        " message format
        let g:ale_echo_msg_error_str   = 'E'
        let g:ale_echo_msg_warning_str = 'W'
        let g:ale_echo_msg_format      = '[%linter%] %s [%code%]'
        let g:ale_fix_on_save          = 0
        let g:ale_set_loclist          = 0
        let g:ale_set_quickfix         = 0
        let g:ale_statusline_format    = ['E:%d', 'W:%d', '']
        let g:ale_python_flake8_options = " --ignore=E501,E251,E226,E221 "
        " 特定后缀指定lint方式
        let g:ale_pattern_options_enabled = 1
        let b:ale_warn_about_trailing_whiteSpace = 0
        nmap <C-l><C-l> :ALELint<CR>
        nmap <silent> <C-l>p <Plug>(ale_previous_wrap)
        nmap <silent> <C-l>n <Plug>(ale_next_wrap)
        nnoremap gt :ALEGoToDefinitionInTab<CR>
        nnoremap gd :ALEGoToDefinition<CR>
    elseif HasDirectory("syntastic")
        let g:syntastic_error_symbol             = 'E'
        let g:syntastic_warning_symbol           = 'W'
        let g:syntastic_check_on_open            = 0
        let g:syntastic_check_on_wq              = 0
        let g:syntastic_python_checkers          = ['pyflakes'] " 使用pyflakes,速度比pylint快
        let g:syntastic_javascript_checkers      = ['jsl', 'jshint']
        let g:syntastic_html_checkers            = ['tidy', 'jshint']
        let g:syntastic_enable_highlighting      = 0
        " to see error location list
        let g:syntastic_always_populate_loc_list = 0
        let g:syntastic_auto_loc_list            = 0
        let g:syntastic_loc_list_height          = 5
        function! ToggleErrors()
            let old_last_winnr = winnr('$')
            lclose
            if old_last_winnr == winnr('$')
                Errors
            endif
        endfunction
        nmap <silent> <C-l><C-l> :call ToggleErrors()<cr>
        nmap <silent> <C-l>n :lnext<cr>
        nmap <silent> <C-l>p :lprevious<cr>
    endif

    if HasDirectory("asyncrun.vim")
        let g:asyncrun_rootmarks = ['.svn', '.git', '.root', '_darcs', 'build.xml']
        function! s:RUN_ASYNC()
            exec "w"
            call asyncrun#quickfix_toggle(8,1)
            if &filetype == 'c'
                exec ":AsyncRun g++ % -o %<"
                exec ":AsyncRun ./%<"
            elseif &filetype == 'cpp'
                exec ":AsyncRun g++ % -o %<"
                exec ":AsyncRun ./%<"
            elseif &filetype == 'java'
                exec ":AsyncRun javac %"
                exec ":AsyncRun java %<"
            elseif &filetype == 'sh'
                exec ":AsyncRun bash %"
            elseif &filetype == 'python'
                exec ":AsyncRun python %"
            elseif &filetype == 'perl'
                exec ":AsyncRun perl %"
            elseif &filetype == 'go'
                exec ":AsyncRun go run %"
            endif
        endfunction
        command! RunAsync call s:RUN_ASYNC()
        nmap <C-b>r        :RunAsync<CR>
        nmap <C-b>s        :AsyncStop<CR>
        nmap <localleade>R :AsyncRun<Space>
    endif

    if HasDirectory("vim-quickrun")
        nnoremap <F5> :QuickRun<Cr>
        inoremap <F5> <ESC>:QuickRun<Cr>
        snoremap <F5> <ESC>:QuickRun<Cr>
        vnoremap <F5> <ESC>:QuickRun<Cr>
        let g:quickrun_config={"_":{"outputter":"message"}}
        let g:quickfix_is_open = 0
        function! ToggleQuickfix()
            if g:quickfix_is_open
                cclose
                cclose
                let g:quickfix_is_open = 0
                execute g:quickfix_return_to_window . "wincmd w"
            else
                let g:quickfix_return_to_window = winnr()
                copen
                let g:quickfix_is_open = 1
            endif
        endfunction
        command! ToggleQuickfix
                    \ call ToggleQuickfix()
        nnoremap <silent><F4> :ToggleQuickfix<cr>
        inoremap <silent><F4> <ESC>:ToggleQuickfix<cr>
        vnoremap <silent><F4> <ESC>:ToggleQuickfix<cr>
        snoremap <silent><F4> <ESC>:ToggleQuickfix<cr>
    endif

endif


" syntastic {{{
if has_key(g:plugs, 'syntastic')
    " dependence
    " 1. shellcheck `brew install shellcheck` https://github.com/koalaman/shellcheck

    let g:syntastic_error_symbol='>>'
    let g:syntastic_warning_symbol='>'
    let g:syntastic_check_on_open=1
    let g:syntastic_check_on_wq=0
    let g:syntastic_enable_highlighting=1

    " checkers
    " python
    " pip install flake8
    let g:syntastic_python_checkers=['flake8', ] " 使用pyflakes,速度比pylint快
    let g:syntastic_python_flake8_options='--ignore=E501,E225,E124,E712,E116,E131'

    " javascript
    " let g:syntastic_javascript_checkers = ['jsl', 'jshint']
    " let g:syntastic_html_checkers=['tidy', 'jshint']
    " npm install -g eslint eslint-plugin-standard eslint-plugin-promise eslint-config-standard
    " npm install -g eslint-plugin-import eslint-plugin-node eslint-plugin-html babel-eslint
    let g:syntastic_javascript_checkers = ['eslint']

    " to see error location list
    let g:syntastic_always_populate_loc_list = 1
    let g:syntastic_enable_signs = 1
    let g:syntastic_auto_loc_list = 0
    let g:syntastic_auto_jump = 0
    let g:syntastic_loc_list_height = 5

    function! ToggleErrors()
        let old_last_winnr = winnr('$')
        lclose
        if old_last_winnr == winnr('$')
            " Nothing was closed, open syntastic_error location panel
            Errors
        endif
    endfunction
    nnoremap <Leader>s :call ToggleErrors()<cr>

    " ,en ,ep to jump between errors
    function! <SID>LocationPrevious()
    try
        lprev
    catch /^Vim\%((\a\+)\)\=:E553/
        llast
    endtry
    endfunction

    function! <SID>LocationNext()
    try
        lnext
    catch /^Vim\%((\a\+)\)\=:E553/
        lfirst
    endtry
    endfunction

    nnoremap <silent> <Plug>LocationPrevious    :<C-u>exe 'call <SID>LocationPrevious()'<CR>
    nnoremap <silent> <Plug>LocationNext        :<C-u>exe 'call <SID>LocationNext()'<CR>
    nmap <silent> <Leader>ep    <Plug>LocationPrevious
    nmap <silent> <Leader>en    <Plug>LocationNext

    " 修改高亮的背景色, 适应主题
    highlight SyntasticErrorSign guifg=white guibg=black

    " 禁止插件检查java
    " thanks to @marsqing, see https://github.com/wklken/k-vim/issues/164
    let g:syntastic_mode_map = {'mode': 'active', 'passive_filetypes': ['java'] }

    " 关闭syntastic语法检查, 鼠标复制代码时用到, 防止把错误标志给复制了
    nnoremap <silent> <Leader>ec :SyntasticToggleMode<CR>
endif
" }}}


" ale {{{
if has_key(g:plugs, 'ale')
    " pip install flake8
    " npm install -g eslint eslint-plugin-standard eslint-plugin-promise eslint-config-standard
    " npm install -g eslint-plugin-import eslint-plugin-node eslint-plugin-html babel-eslint
    let g:ale_linters = {
    \   'python': ['flake8'],
    \   'javascript': ['eslint'],
    \}

    " E501 -> 120 chars
    let g:ale_python_flake8_args="--ignore=E114,E116,E131 --max-line-length=120"
    " --ignore=E225,E124,E712,E116

    let g:ale_sign_error = '>>'
    let g:ale_sign_warning = '>'

    let g:ale_statusline_format = ['⨉ %d', '⚠ %d', '⬥ ok']
    let g:ale_echo_msg_error_str = 'E'
    let g:ale_echo_msg_warning_str = 'W'
    let g:ale_echo_msg_format = '[%linter%] %s [%severity%]'

    nmap <silent> <Leader>ep <Plug>(ale_previous_wrap)
    nmap <silent> <Leader>en <Plug>(ale_next_wrap)

    nnoremap <silent> <Leader>ec :ALEToggle<CR>

    " troggle quickfix list
    function! ToggleErrors()
        let old_last_winnr = winnr('$')
        lclose
        if old_last_winnr == winnr('$')
            " Nothing was closed, open syntastic_error location panel
            lopen
        endif
    endfunction
    nnoremap <Leader>s :call ToggleErrors()<cr>

    let g:ale_set_highlights = 1
    highlight clear ALEErrorSign
    highlight clear ALEWarningSign
endif

" }}}

" ################### 自动补全 ###################

" YouCompleteMe {{{
    "youcompleteme  默认tab  s-tab 和自动补全冲突
    "let g:ycm_key_list_select_completion=['<c-n>']
    let g:ycm_key_list_select_completion = ['<Down>']
    "let g:ycm_key_list_previous_completion=['<c-p>']
    let g:ycm_key_list_previous_completion = ['<Up>']
    let g:ycm_complete_in_comments = 1  "在注释输入中也能补全
    let g:ycm_complete_in_strings = 1   "在字符串输入中也能补全
    let g:ycm_use_ultisnips_completer = 1 "提示UltiSnips
    let g:ycm_collect_identifiers_from_comments_and_strings = 1   "注释和字符串中的文字也会被收入补全
    let g:ycm_collect_identifiers_from_tags_files = 1
    " 开启语法关键字补全
    let g:ycm_seed_identifiers_with_syntax=1
    " 回车作为选中
    let g:ycm_key_list_stop_completion = ['<CR>']

    "let g:ycm_seed_identifiers_with_syntax=1   "语言关键字补全, 不过python关键字都很短，所以，需要的自己打开

    " 跳转到定义处, 分屏打开
    let g:ycm_goto_buffer_command = 'horizontal-split'
    let g:ycm_register_as_syntastic_checker = 0
    " nnoremap <leader>jd :YcmCompleter GoToDefinition<CR>
    nnoremap <leader>jd :YcmCompleter GoToDefinitionElseDeclaration<CR>
    nnoremap <leader>gd :YcmCompleter GoToDeclaration<CR>

    " 引入，可以补全系统，以及python的第三方包 针对新老版本YCM做了兼容
    " old version
    if !empty(glob("~/.vim/bundle/YouCompleteMe/cpp/ycm/.ycm_extra_conf.py"))
        let g:ycm_global_ycm_extra_conf = "~/.vim/bundle/YouCompleteMe/cpp/ycm/.ycm_extra_conf.py"
    endif
    " new version
    if !empty(glob("~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py"))
        let g:ycm_global_ycm_extra_conf = "~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py"
    endif

    " 直接触发自动补全 insert模式下
    " let g:ycm_key_invoke_completion = '<C-Space>'
    " 黑名单,不启用
    let g:ycm_filetype_blacklist = {
        \ 'tagbar' : 1,
        \ 'gitcommit' : 1,
        \}
" }}}


" ultisnips {{{
    let g:UltiSnipsExpandTrigger       = "<tab>"
    let g:UltiSnipsJumpForwardTrigger  = "<tab>"
    let g:UltiSnipsJumpBackwardTrigger = "<s-tab>"
    let g:UltiSnipsSnippetDirectories  = ['UltiSnips']
    let g:UltiSnipsSnippetsDir = '~/.vim/UltiSnips'
    " 定义存放代码片段的文件夹 .vim/UltiSnips下，使用自定义和默认的，将会的到全局，有冲突的会提示
    " 进入对应filetype的snippets进行编辑
    map <leader>us :UltiSnipsEdit<CR>

    " ctrl+j/k 进行选择
    func! g:JInYCM()
        if pumvisible()
            return "\<C-n>"
        else
            return "\<c-j>"
        endif
    endfunction

    func! g:KInYCM()
        if pumvisible()
            return "\<C-p>"
        else
            return "\<c-k>"
        endif
    endfunction
    inoremap <c-j> <c-r>=g:JInYCM()<cr>
    au BufEnter,BufRead * exec "inoremap <silent> " . g:UltiSnipsJumpBackwordTrigger . " <C-R>=g:KInYCM()<cr>"
    let g:UltiSnipsJumpBackwordTrigger = "<c-k>"
" }}}


" delimitMate {{{
    " for python docstring ",优化输入
    au FileType python let b:delimitMate_nesting_quotes = ['"']
    au FileType php let delimitMate_matchpairs = "(:),[:],{:}"
    " 关闭某些类型文件的自动补全
    "au FileType mail let b:delimitMate_autoclose = 0
" }}}


" closetag {{{
    let g:closetag_html_style=1
" }}}

" ################### 快速编码 ###################

" nerdcommenter {{{
    let g:NERDSpaceDelims=1
    let g:NERDAltDelims_python = 1
" }}}

" trailingwhitespace {{{
    map <leader><space> :FixWhitespace<cr>
" }}}

" easyalign {{{
    vmap <Leader>a <Plug>(EasyAlign)
    nmap <Leader>a <Plug>(EasyAlign)
    if !exists('g:easy_align_delimiters')
    let g:easy_align_delimiters = {}
    endif
    let g:easy_align_delimiters['#'] = { 'pattern': '#', 'ignore_groups': ['String'] }
    " Default:
    " If a delimiter is in a highlight group whose name matches any of the followings, it will be ignored.
    let g:easy_align_ignore_groups = ['Comment', 'String']
" }}}

" ################### 快速移动 ###################

" easymotion {{{
    let g:EasyMotion_smartcase = 1
    "let g:EasyMotion_startofline = 0 " keep cursor colum when JK motion
    map <Leader><leader>h <Plug>(easymotion-linebackward)
    map <Leader><Leader>j <Plug>(easymotion-j)
    map <Leader><Leader>k <Plug>(easymotion-k)
    map <Leader><leader>l <Plug>(easymotion-lineforward)
    " 重复上一次操作, 类似repeat插件, 很强大
    map <Leader><leader>. <Plug>(easymotion-repeat)
" }}}


" quickscope {{{
    let g:qs_highlight_on_keys = ['f', 'F', 't', 'T']
    " macvim/gvim会有问题, 暂时注解
    " let g:qs_first_occurrence_highlight_color = '#afff5f' " gui vim
    " let g:qs_first_occurrence_highlight_color = 155       " terminal vim
    " let g:qs_second_occurrence_highlight_color = '#5fffff'  " gui vim
    " let g:qs_second_occurrence_highlight_color = 81         " terminal vim
" }}}

" ################### 快速选中 ###################

" expandregion {{{
    " map + <Plug>(expand_region_expand)
    " map _ <Plug>(expand_region_shrink)
    vmap v <Plug>(expand_region_expand)
    vmap V <Plug>(expand_region_shrink)
    " Extend the global default
    if exists("*expand_region#custom_text_objects")
        call expand_region#custom_text_objects({
        \ 'a]' :1,
        \ 'ab' :1,
        \ 'aB' :1,
        \ 'ii' :0,
        \ 'ai' :0,
        \ })
    endif

" }}}

" multiplecursors {{{
    let g:multi_cursor_use_default_mapping=0
    " Default mapping
    let g:multi_cursor_next_key='<C-m>'
    let g:multi_cursor_prev_key='<C-p>'
    let g:multi_cursor_skip_key='<C-x>'
    let g:multi_cursor_quit_key='<Esc>'
" }}}

" ################### 功能相关 ###################

" ctrlp ctrlpfunky{{{
    let g:ctrlp_map = '<leader>p'
    let g:ctrlp_cmd = 'CtrlP'
    map <leader>f :CtrlPMRU<CR>
    let g:ctrlp_custom_ignore = {
        \ 'dir':  '\v[\/]\.(git|hg|svn|rvm)$',
        \ 'file': '\v\.(exe|so|dll|zip|tar|tar.gz|pyc)$',
        \ }
    let g:ctrlp_working_path_mode=0
    let g:ctrlp_match_window_bottom=1
    let g:ctrlp_max_height=15
    let g:ctrlp_match_window_reversed=0
    let g:ctrlp_mruf_max=500
    let g:ctrlp_follow_symlinks=1
    " 如果安装了ag, 使用ag
    " if executable('ag')
    " " Use ag in CtrlP for listing files. Lightning fast and respects .gitignore
    " let g:ctrlp_user_command = 'ag %s -l --nocolor -g ""'
    " " ag is fast enough that CtrlP doesn't need to cache
    " let g:ctrlp_use_caching = 0
    " endif

    " ctrlpfunky
    " ctrlp插件1 - 不用ctag进行函数快速跳转
    nnoremap <Leader>fu :CtrlPFunky<Cr>
    " narrow the list down with a word under cursor
    nnoremap <Leader>fU :execute 'CtrlPFunky ' . expand('<cword>')<Cr>
    let g:ctrlp_funky_syntax_highlight = 1

    let g:ctrlp_extensions = ['funky']
" }}}


" ctrlsf {{{
    nmap \ <Plug>CtrlSFCwordPath<CR>
    " let g:ctrlsf_position = 'below'
    " let g:ctrlsf_winsize = '30%'
    let g:ctrlsf_auto_close = 0
    let g:ctrlsf_confirm_save = 0
    " Note: cannot use <CR> or <C-m> for open
    " Use : <sapce> or <tab>
    let g:ctrlsf_mapping = {
        \ "open"  : "<Space>",
        \ "openb" : "O",
        \ "tab"   : "t",
        \ "tabb"  : "T",
        \ "prevw" : "p",
        \ "quit"  : "q",
        \ "next"  : "<C-J>",
        \ "prev"  : "<C-K>",
        \ "pquit" : "q",
        \ }
" }}}

" git.  git操作还是习惯命令行,vim里面处理简单diff编辑操作

" fugitive {{{
    " :Gdiff  :Gstatus :Gvsplit
    nnoremap <leader>ge :Gdiff<CR>
    " not ready to open
    " <leader>gb maps to :Gblame<CR>
    " <leader>gs maps to :Gstatus<CR>
    " <leader>gd maps to :Gdiff<CR>  和现有冲突
    " <leader>gl maps to :Glog<CR>
    " <leader>gc maps to :Gcommit<CR>
    " <leader>gp maps to :Git push<CR>
" }}}

" gitgutter {{{
    " 同git diff,实时展示文件中修改的行
    " 只是不喜欢除了行号多一列, 默认关闭,gs时打开
    let g:gitgutter_map_keys = 0
    let g:gitgutter_enabled = 0
    let g:gitgutter_highlight_lines = 1
    nnoremap <leader>gs :GitGutterToggle<CR>
" }}}

" gundo {{{
    noremap <leader>h :GundoToggle<CR>
" }}}

" ################### 显示增强 ###################

" airline {{{
    if !exists('g:airline_symbols')
        let g:airline_symbols = {}
    endif
    let g:airline_left_sep = '▶'
    let g:airline_left_alt_sep = '❯'
    let g:airline_right_sep = '◀'
    let g:airline_right_alt_sep = '❮'
    let g:airline_symbols.linenr = '¶'
    let g:airline_symbols.branch = '⎇'
    " 是否打开tabline
    " let g:airline#extensions#tabline#enabled = 1
" }}}



" rainbow_parentheses {{{
    " 不加入这行, 防止黑色括号出现, 很难识别
    " \ ['black',       'SeaGreen3'],
    let g:rbpt_colorpairs = [
        \ ['brown',       'RoyalBlue3'],
        \ ['Darkblue',    'SeaGreen3'],
        \ ['darkgray',    'DarkOrchid3'],
        \ ['darkgreen',   'firebrick3'],
        \ ['darkcyan',    'RoyalBlue3'],
        \ ['darkred',     'SeaGreen3'],
        \ ['darkmagenta', 'DarkOrchid3'],
        \ ['brown',       'firebrick3'],
        \ ['gray',        'RoyalBlue3'],
        \ ['darkmagenta', 'DarkOrchid3'],
        \ ['Darkblue',    'firebrick3'],
        \ ['darkgreen',   'RoyalBlue3'],
        \ ['darkcyan',    'SeaGreen3'],
        \ ['darkred',     'DarkOrchid3'],
        \ ['red',         'firebrick3'],
        \ ]

    let g:rbpt_max = 16
    let g:rbpt_loadcmd_toggle = 0
    au VimEnter * RainbowParenthesesToggle
    au Syntax * RainbowParenthesesLoadRound
    au Syntax * RainbowParenthesesLoadSquare
    au Syntax * RainbowParenthesesLoadBraces
" }}}


" ################### 显示增强-主题 ###################"

" solarized {{{
    let g:solarized_termtrans=1
    let g:solarized_contrast="normal"
    let g:solarized_visibility="normal"
    " let g:solarized_termcolors=256
" }}}

" molokai {{{
    " monokai原始背景色
    let g:molokai_original = 1
    let g:rehash256 = 1
" }}}

" ################### 快速导航 ###################

" nerdtree nerdtreetabs {{{
    " map <leader>n :NERDTreeToggle<CR>
    let NERDTreeHighlightCursorline=1
    let NERDTreeIgnore=[ '\.pyc$', '\.pyo$', '\.obj$', '\.o$', '\.so$', '\.egg$', '^\.git$', '^\.svn$', '^\.hg$' ]
    "close vim if the only window left open is a NERDTree
    autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTreeType") && b:NERDTreeType == "primary") | q | end
    " s/v 分屏打开文件
    let g:NERDTreeMapOpenSplit = 's'
    let g:NERDTreeMapOpenVSplit = 'v'


    " nerdtreetabs
    map <Leader>n <plug>NERDTreeTabsToggle<CR>
    " 关闭同步
    " let g:nerdtree_tabs_synchronize_view=0
    " let g:nerdtree_tabs_synchronize_focus=0
    " 是否自动开启nerdtree
    " thank to @ListenerRi, see https://github.com/wklken/k-vim/issues/165
    let g:nerdtree_tabs_open_on_console_startup=0
    let g:nerdtree_tabs_open_on_gui_startup=0
" }}}


" Vim Workspace Controller
" ctrlspace {{{
    let g:airline_exclude_preview = 1
    hi CtrlSpaceSelected guifg=#586e75 guibg=#eee8d5 guisp=#839496 gui=reverse,bold ctermfg=10 ctermbg=7 cterm=reverse,bold
    hi CtrlSpaceNormal   guifg=#839496 guibg=#021B25 guisp=#839496 gui=NONE ctermfg=12 ctermbg=0 cterm=NONE
    hi CtrlSpaceSearch   guifg=#cb4b16 guibg=NONE gui=bold ctermfg=9 ctermbg=NONE term=bold cterm=bold
    hi CtrlSpaceStatus   guifg=#839496 guibg=#002b36 gui=reverse term=reverse cterm=reverse ctermfg=12 ctermbg=8
" }}}


" 标签导航
" tagbar {{{
    nmap <F9> :TagbarToggle<CR>
    let g:tagbar_autofocus = 1
    " let g:tagbar_autoshowtag = 1
    " let g:tagbar_show_visibility = 1
    " for ruby
    let g:tagbar_type_ruby = {
        \ 'kinds' : [
            \ 'm:modules',
            \ 'c:classes',
            \ 'd:describes',
            \ 'C:contexts',
            \ 'f:methods',
            \ 'F:singleton methods'
        \ ]
    \ }

    " go语言的tagbar配置
    " 1. install gotags 'go get -u github.com/jstemmer/gotags'
    " 2. make sure `gotags` in you shell PATH, you can call check it with `which gotags`
    " for gotags. work with tagbar
    let g:tagbar_type_go = {
        \ 'ctagstype' : 'go',
        \ 'kinds'     : [
            \ 'p:package',
            \ 'i:imports:1',
            \ 'c:constants',
            \ 'v:variables',
            \ 't:types',
            \ 'n:interfaces',
            \ 'w:fields',
            \ 'e:embedded',
            \ 'm:methods',
            \ 'r:constructor',
            \ 'f:functions'
        \ ],
        \ 'sro' : '.',
        \ 'kind2scope' : {
            \ 't' : 'ctype',
            \ 'n' : 'ntype'
        \ },
        \ 'scope2kind' : {
            \ 'ctype' : 't',
            \ 'ntype' : 'n'
        \ },
        \ 'ctagsbin'  : 'gotags',
        \ 'ctagsargs' : '-sort -silent'
    \ }
" }}}


" ################### 语言相关 ###################

" quickrun {{{
    let g:quickrun_config = {
    \   "_" : {
    \       "outputter" : "message",
    \   },
    \}

    let g:quickrun_no_default_key_mappings = 1
    nmap <Leader>r <Plug>(quickrun)
    map <F10> :QuickRun<CR>
" }}}


" pythonsyntax {{{
    let python_highlight_all = 1
" }}}

" piv {{{
    let g:DisableAutoPHPFolding = 1
" }}}


" vimgo {{{
    let g:go_highlight_functions = 1
    let g:go_highlight_methods = 1
    let g:go_highlight_structs = 1
    let g:go_highlight_operators = 1
    let g:go_highlight_build_constraints = 1

    let g:go_fmt_fail_silently = 1
    " format with goimports instead of gofmt
    let g:go_fmt_command = "goimports"
    let g:syntastic_go_checkers = ['golint', 'govet', 'errcheck']
    let g:syntastic_mode_map = { 'mode': 'active', 'passive_filetypes': ['go', 'java'] }
" }}}

" markdown {{{
    let g:vim_markdown_folding_disabled=1
" }}}


" javascript {{{
    " pangloss/vim-javascript
    let g:html_indent_inctags = "html,body,head,tbody"
    let g:html_indent_script1 = "inc"
    let g:html_indent_style1 = "inc"
" }}}

" json {{{
    let g:vim_json_syntax_conceal = 0
" }}}

" css {{{
" }}}


" ####### temp #######

" beta {{{
    " pip install yapf
    " python code format
    " format all file
    autocmd FileType python nnoremap <leader>y :0,$!yapf<Cr>
    " format select block
    autocmd FileType python vnoremap <leader>y :!yapf<Cr>

    " Plug 'posva/vim-vue'

    " Plug 'millermedeiros/vim-esformatter'
    " will run esformatter after pressing <leader> followed by the 'e' and 's'
    " keys
    " nnoremap <silent> <leader>es :Esformatter<CR>
    " vnoremap <silent> <leader>es :EsformatterVisual<CR>

" }}}
